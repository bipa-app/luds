LUD-21: Currencies in `payRequest`.
=================================

`author: lsunsi`
`author: luizParreira`
`author: lorenzolfm`

---

## Support for LNURL-pay currencies

This document describes an extension to the [payRequest](https://github.com/lnurl/luds/blob/luds/06.md) base specification that allows the `WALLET` to send money to a `SERVICE` denominating the amount in a different currency. The features proposed enable many use cases ranging from denominating an invoice in a foreign currency to a remittance-like experience.

The main features provided by this extension are:
- `SERVICE` **MUST** inform `WALLET` what currencies it supports
- `WALLET` **MAY** request an invoice with amount denominated in one of the currencies
- `WALLET` **MAY** request to the payment to be converted into one of the currencies
- `WALLET` **MAY** inform the `SERVICE` the amount and currency used the buy the amount being paid

The extension is opt-in and backwards compatible. Further, a supporting `WALLET` can always tell if a `SERVICE` is also supporting beforehand so the communication is never ambiguous.

### Wallet-side first request

The first request is unchanged from the base specification.

### Service-side first response

`SERVICE` must alter its JSON response to the first callback to include a `currencies` field, as follows:

```typescript
type BaseResponse = {
    tag: "payRequest",
    metadata: string,
    callback: string,
    maxSendable: number,
    minSendable: number
}

type Currency = {
  code: string, // Code of the currency, used as an ID for it. E.g.: BRL
  name: string, // Name of the currency. E.g.: Reais
  symbol: string, // Symbol of the currency. E.g.: R$
  decimals: number, // Integer; Number of decimal places. E.g.: 2
  multiplier: number, // Double; Number of millisatoshis per smallets unit of currency. E.g.: 5405.405
  convertible?: bool // Whether the currency can be converted into.
}

type ExtendedResponse = BaseResponse & {
  currencies: Currency[]
}
```

```diff
{
  "tag": "payRequest",
  "metadata": '[["text/plain","$kenu ⚡ bipa.app"]]',
  "callback": "https://api.bipa.app/ln/request/invoice/kenu",
  "maxSendable": 1000000000,
  "minSendable": 1000,
+ "currencies": [
+   {
+     "code": "BRL",
+     "name": "Real",
+     "symbol": "R$",
+     "decimals": 2,
+     "multiplier": 5404.405,
+     "convertible": true
+   }
+ ]
}
```

- The inclusion of the `currencies` field implies the support of this extension
- The inclusion of a `currency` implies it can be used for denomination of an amount
- The inclusion of a `convertible currency` implies the `SERVICE` can quote and guarantee a price for given currency
- The `multiplier` returned on this response is not guaranteed by the `SERVICE` and is subject to change
- The `code` of a `currency` will be used as an identifier for the next request and must be unique
- The `code` and other information must be according to [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217) for currencies that are included in it
- The order of the `currencies` must be interpreted by the `WALLET` as the receiving user preference for a currency

### Wallet-side second request

Upon receiving the `currencies` field on the response, the `WALLET` shows the user it has the option of denominating the amount in one of the `currencies` or for the payment to be credit as the different currency for the receiver. If the BTC being used for the payment is was bought as part of the payment, the `WALLET` may inform the `SERVICE` about it's cost.

The inputs that must be gathered from the user are:
- An optional denominating currency and amount (`CURRENCY_D` and `AMOUNT_D`)
- An optional source currency and amount (`CURRENCY_S` and `AMOUNT_S`)
- An optional target currency (`CURRENCY_T`)

The most general case has all the possible parameters present.
It will generate an invoice with amount equivalent to `AMOUNT_D` `CURRENCY_D`, that will be converted into `CURRENCY_T` by the `SERVICE` upon payment, which will be done with BTC that costed the sender `AMOUNT_S` `CURRENCY_S`.

`<callback><?|&>amount=<AMOUNT_D>.<CURRENCY_D>&source=<AMOUNT_S>.<CURRENCY_S>&target=<CURRENCY_T>`

Each combination of parameters is valid and generates a different use case.
- Ommiting the `amount` denomination implies the invoice is for millisatoshis (base spec)
- Ommiting the `source` prevents the receiver from knowing the cost of the BTC being sent
- Ommiting the `target` implies the receiver will get BTC from the payment, no matter the `source` or `amount` denomination

Note that the amount provided in all requests is always an integer number interpreted as the smallest unit of the selected `currency`. The smallest unit needs to be according to the `decimals` parameter, so the `WALLET` has all the needed information to receive input and show output properly.

### Service-side second response

Upon receiving a currency denominated request from `WALLET`, the `SERVICE` must return an invoice with an amount matching the converted rate for the amount in that currency. The rate used does not need to match the `multiplier` first informed.

If the `WALLET` requested an actual conversion, the `SERVICE` must provide an additional field alongside the invoice informing the guaranteed `converted` amount that will be credit to the receiver upon payment. The `converted` amount, and therefore the conversion rate, must be guaranteed by the `SERVICE` for as long as the invoice is not expired. The `converted` amount must be denominated in the smallest unit of the currency, just like the `amount` parameter.

If the `WALLET` informed the `SERVICE` about the cost of the BTC used in the payment, the `SERVICE` may use the information to display currency-to-currency exchange rates.

```typescript
type BaseResponse = {
  pr: string,
  routes: [],
}

type ExtendedResponse = BaseResponse & {
  converted?: number, // Integer; Present if and only if `target` was received.
}
```

```diff
{
  "pr": "lnbc1230n1pjknkl...ju36m3lyytlwv42fee8gpt6vd2v",
  "routes": [],
+ "converted": 123
}
```

### Examples
These examples show all the possible uses of this extension by a supporting `WALLET` and `SERVICE`.

#### Payer queries the payee service
`GET <service>/.well-known/lnurlp/<identifier>`
```json
{
  "tag": "payRequest",
  "callback": "bipa.app/callback",
  "metadata": "...",
  "minSendable": 1000,
  "maxSendable": 1000000,
  "currencies": [
    {
      "code": "BRL",
      "name": "Reais",
      "symbol": "R$",
      "decimals": 2,
      "multiplier": 5405.405,
      "convertible": true
    },
    {
      "code": "USDT",
      "name": "Tether",
      "symbol": "₮",
      "decimals": 6,
      "multiplier": 26315.789
    }
  ]
}
```
###### Payer sends 538 sats
```json5
// GET <callback>?amount=538000
{ "pr": "(invoice of 538 sats)" }
```
###### Payer sends 1 BRL worth of BTC
```json5
// GET <callback>?amount=100.BRL
{ "pr": "(invoice of 538 sats)" }
```
###### Payer sends 538 sats to be converted into BRL
```json5
// GET <callback>?amount=538000&target=BRL
{ "converted": 100, "pr": "(invoice of 538 sats)" }
```
###### Payer sends 538 sats that costed 0.2 USDT
```json5
// GET <callback>?amount=538000&source=200000.USDT
{ "pr": "(invoice of 538 sats)" }
```
###### Payer sends 1 BRL worth of BTC to be converted into USDT
```json5
// GET <callback>?amount=100.BRL&target=USDT
{ "converted": 200000, "pr": "(invoice of 538 sats)" }
```
###### Payer sends 1 BRL worth of BTC that costed 0.2 USDT
```json5
// GET <callback>?amount=100.BRL&source=200000.USDT
{ "pr": "(invoice of 538 sats)" }
```
###### Payer sends 538 sats that costed 0.2 USDT to be converted into BRL
```json5
// GET <callback>?amount=538000&source=200000.USDT&target=BRL
{ "converted": 100, "pr": "(invoice of 538 sats)" }
```
###### Payer sends 1 BRL worth of BTC that costed 0.2 USDT to converted into BRL
```json5
// GET <callback>?amount=100.BRL&source=200000.USDT&target=BRL
{ "converted": 100, "pr": "(invoice of 538 sats)" }
```
###### Payer sends 1 BRL worth of BTC to unsupported service
```json5
// GET <callback>?amount=100.BRL
{ "status": "ERROR", "reason": "..." }
```

### Related work

- Some of the ideas included in this PR were taken from the implementation and discussion on [this PR](https://github.com/lnurl/luds/pull/207). Most precisely, @ethanrose (author) and @callebtc (contributor).

- Some early ideas for this including some other aspects of it were hashed out (but not pull-requested) in this [earlier draft](https://github.com/bipa-app/lnurl-rfc/pull/1) too. Thanks @luizParreira (author), @joosjager (contributor), @za-kk (contributor).
